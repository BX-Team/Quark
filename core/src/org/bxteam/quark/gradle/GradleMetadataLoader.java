package org.bxteam.quark.gradle;

import org.bxteam.quark.dependency.Dependency;
import org.bxteam.quark.relocation.Relocation;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.*;

import static java.util.Objects.requireNonNull;

/**
 * Loads dependencies and configuration from Gradle plugin generated metadata.
 *
 * <p>This class reads the metadata files generated by the Quark Gradle plugin
 * and provides easy access to dependencies, repositories, and relocations
 * configured at build time.</p>
 */
public class GradleMetadataLoader {
    private static final String DEPENDENCIES_FILE = "quark/dependencies.txt";
    private static final String REPOSITORIES_FILE = "quark/repositories.txt";
    private static final String RELOCATIONS_FILE = "quark/relocations.txt";

    private final List<Dependency> dependencies;
    private final List<String> repositories;
    private final List<Relocation> relocations;

    /**
     * Creates a new metadata loader and loads all metadata from resources.
     *
     * @param resourceProvider the provider for accessing embedded resources
     * @throws GradleMetadataException if metadata loading fails
     */
    public GradleMetadataLoader(@NotNull ResourceProvider resourceProvider) {
        requireNonNull(resourceProvider, "Resource provider cannot be null");

        this.dependencies = loadDependencies(resourceProvider);
        this.repositories = loadRepositories(resourceProvider);
        this.relocations = loadRelocations(resourceProvider);
    }

    /**
     * Gets the list of dependencies from Gradle metadata.
     *
     * @return immutable list of dependencies
     */
    @NotNull
    public List<Dependency> getDependencies() {
        return Collections.unmodifiableList(dependencies);
    }

    /**
     * Gets the list of repository URLs from Gradle metadata.
     *
     * @return immutable list of repository URLs
     */
    @NotNull
    public List<String> getRepositories() {
        return Collections.unmodifiableList(repositories);
    }

    /**
     * Gets the list of relocations from Gradle metadata.
     *
     * @return immutable list of relocations
     */
    @NotNull
    public List<Relocation> getRelocations() {
        return Collections.unmodifiableList(relocations);
    }

    /**
     * Checks if relocations are configured.
     *
     * @return true if relocations are available
     */
    public boolean hasRelocations() {
        return !relocations.isEmpty();
    }

    /**
     * Checks if dependencies are configured.
     *
     * @return true if dependencies are available
     */
    public boolean hasDependencies() {
        return !dependencies.isEmpty();
    }

    /**
     * Checks if repositories are configured.
     *
     * @return true if repositories are available
     */
    public boolean hasRepositories() {
        return !repositories.isEmpty();
    }

    /**
     * Loads dependencies from the dependencies.txt file.
     *
     * @param resourceProvider the resource provider
     * @return list of loaded dependencies
     */
    @NotNull
    private List<Dependency> loadDependencies(@NotNull ResourceProvider resourceProvider) {
        InputStream stream = resourceProvider.getResourceAsStream(DEPENDENCIES_FILE);
        if (stream == null) {
            return Collections.emptyList();
        }

        List<Dependency> deps = new ArrayList<>();
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(stream, StandardCharsets.UTF_8))) {
            String line;
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                if (!line.isEmpty() && !line.startsWith("#")) {
                    try {
                        deps.add(Dependency.fromCoordinates(line));
                    } catch (IllegalArgumentException e) {
                        throw new GradleMetadataException("Invalid dependency format: " + line, e);
                    }
                }
            }
        } catch (IOException e) {
            throw new GradleMetadataException("Failed to read dependencies metadata", e);
        }

        return deps;
    }

    /**
     * Loads repositories from the repositories.txt file.
     *
     * @param resourceProvider the resource provider
     * @return list of repository URLs
     */
    @NotNull
    private List<String> loadRepositories(@NotNull ResourceProvider resourceProvider) {
        InputStream stream = resourceProvider.getResourceAsStream(REPOSITORIES_FILE);
        if (stream == null) {
            return Collections.emptyList();
        }

        List<String> repos = new ArrayList<>();
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(stream, StandardCharsets.UTF_8))) {
            String line;
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                if (!line.isEmpty() && !line.startsWith("#")) {
                    repos.add(line);
                }
            }
        } catch (IOException e) {
            throw new GradleMetadataException("Failed to read repositories metadata", e);
        }

        return repos;
    }

    /**
     * Loads relocations from the relocations.txt file.
     *
     * @param resourceProvider the resource provider
     * @return list of relocations
     */
    @NotNull
    private List<Relocation> loadRelocations(@NotNull ResourceProvider resourceProvider) {
        InputStream stream = resourceProvider.getResourceAsStream(RELOCATIONS_FILE);
        if (stream == null) {
            return Collections.emptyList();
        }

        List<Relocation> relocs = new ArrayList<>();
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(stream, StandardCharsets.UTF_8))) {
            String line;
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                if (!line.isEmpty() && !line.startsWith("#")) {
                    String[] parts = line.split(":", 2);
                    if (parts.length == 2) {
                        relocs.add(Relocation.of(parts[0], parts[1]));
                    } else {
                        throw new GradleMetadataException("Invalid relocation format: " + line);
                    }
                }
            }
        } catch (IOException e) {
            throw new GradleMetadataException("Failed to read relocations metadata", e);
        }

        return relocs;
    }

    /**
     * Interface for providing access to embedded resources.
     */
    public interface ResourceProvider {
        /**
         * Gets a resource as an input stream.
         *
         * @param resourcePath the path to the resource
         * @return an input stream for the resource, or null if not found
         */
        @Nullable
        InputStream getResourceAsStream(@NotNull String resourcePath);
    }

    /**
     * Exception thrown when Gradle metadata loading fails.
     */
    public static class GradleMetadataException extends RuntimeException {
        /**
         * Creates a new exception with the specified message.
         *
         * @param message the detail message
         */
        public GradleMetadataException(String message) {
            super(message);
        }

        /**
         * Creates a new exception with the specified message and cause.
         *
         * @param message the detail message
         * @param cause the cause of this exception
         */
        public GradleMetadataException(String message, Throwable cause) {
            super(message, cause);
        }
    }
}
